sbt clean coverage test
sbt coverageReport





package de.htwg.se.wii
package aview

import controller.Controller
import model.Hole
import scala.io.StdIn.readLine
import util.Observer
import scala.util.Random
import scala.annotation.switch
import model.Dice
import scala.util.control.Breaks._

class TUI(controller: Controller, size: Int) extends Observer:
  controller.add(this)
  val dice = Dice((size * size))
  val namePlayer1 = "Stefan"
  val namePlayer2 = "Hannes"
  var countPlayer1 = 10
  var countPlayer2 = 10

  val eol = sys.props("line.separator")
  var state = true // true spieler1 am zug

  def run: Unit =
    println("Los geht das Spiel")
    gameLoop()

  override def update = println(controller.toString())

  def gameLoop(): Unit =
    println(controller.field.toString)
    for (a <- 1 to 10) {
      //   if (state) {
      println("Enter fuer Wuerfeln")
      val wurfel = readLine()
      val gewurfelt = dice.roll()
      breakable {
        if (gewurfelt == 0) {
          println("Wurde 0 gewurfelt bleibt das spielfeld gleich")
          if (state) {
            countPlayer1 -= 1
          } else {
            countPlayer2 -= 1
          }
          println(s"Spieler1: $countPlayer1 $eol")

          println(s"Spieler2: $countPlayer2 $eol")
          if (state) {
            state = false
          } else {
            state = true
          }
          break
        }
        if (controller.get(gewurfelt) == Hole.X) {
          if (state) {
            countPlayer1 += 1
          } else {
            countPlayer2 += 1
          }
          controller.put(Hole.O, gewurfelt)
        } else {
          if (state) {
            countPlayer1 -= 1
          } else {
            countPlayer2 -= 1
          }
          controller.put(Hole.X, gewurfelt)
        }
        println(s"Spieler1: $countPlayer1 $eol")
        println(s"Spieler2: $countPlayer2 $eol")
        if (state) {
          state = false
        } else {
          state = true
        }
        break
      }
    }
